<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"> <channel> <title>(gensym)</title> <link>https://plisp.github.io</link> <atom:link href="https://plisp.github.io/rss.xml" rel="self" type="application/rss+xml" /> <language>en-us</language> <pubDate>Sun, 16 Jan 2022 09:10:36 +0000</pubDate> <item> <title>Terminals ARE NOT GUI</title> <link>https://plisp.github.io/posts/Terminals-ARE-NOT-GUI.html</link> <pubDate>2022-01-16 16:02:09</pubDate> <author>plisp</author> <guid isPermaLink="true">https://plisp.github.io/posts/Terminals-ARE-NOT-GUI.html</guid> <category><![CDATA[ terminals ]]></category> <description><![CDATA[ <p>Unless you're dealing solely with ascii, which is typically a naive assumption in our 
Unicode world and <em>especially</em> in the realm of text editing widgets, terminal emulators
should be avoided for the dusty VT100 relics they are.</p>

<p>Not only is input handling unbelievably botched, consistent text rendering
is impossible across terminals.</p>

<!--more-->

<p>To understand the unfixable brokenness we must look inside the terminal:</p>

<p align="center"> <img src="../static/terminal.jpeg"> </p>

<p>The original terminals were physical devices capable of displaying a simple
grid of characters, and so the textual terminal interfaces developed mapped
elegantly to the displays of the time (much prior to Unicode).
However when true GUI caught on, this design meant terminal drivers needed to be
developed with the sole purpose of emulating a physical terminal to support shells
and other programs predating graphical environments, which relied on line buffering
and catching special characters such as ctrl+c.
A UNIXy kernel typically exposes this functionality
through pseudoterminals (PTYs), where bytes written between the
graphical terminal emulator and program can be first mediated by the OS driver.</p>

<p>Ironically &quot;terminal user interfaces&quot; of course immediately disable the kernel's
line buffering and control character processing on startup to regain full control
over user input - you may notice ctrl+c doesn't cause the <code>vim</code> editor to
terminate as batch programs do.</p>

<p align="center"> <img src="../static/pty.png"> </p>

<p>Upon launching a shell program, its standard input/output are connected to the
terminal emulator through the kernel via a pty, allowing the madness to begin.</p>

<p>To see what I mean, run <code>script</code> to start a recursive shell session where input
will be logged to a file called <code>typescript</code> in the current working directory.
Launch any 'graphical' terminal program, exit and ctrl+d to return to your original
shell. Opening <code>typescript</code> with a reliable text editor you see...
an absolutely incomprehensible mess of seemingly random characters.</p>

<p>You may have heard of these strings as terminal escape codes, which precisely
reflected my urge after developing a <a href="https://github.com/Plisp/uncursed" >TUI library</a>.
These unseen sequences are copied between the terminal emulator and TUI program through the pty,
mediating both user input reporting and 'graphical' commands
like 'clear the screen' or 'set the drawing color to flashing red'.</p>

<p>Where are these sequences defined? Prepare yourself and run <code>infocmp</code> in a shell.</p>

<pre><code>xterm|xterm terminal emulator (X Window System),
        am, bce, km, mc5i, mir, msgr, npc, xenl,
        colors#8, cols#80, it#8, lines#24, pairs#64,
        acsc=``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
        bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l,
        clear=\E[H\E[2J, cnorm=\E[?12l\E[?25h, cr=\r,
        csr=\E[%i%p1%d;%p2%dr, cub=\E[%p1%dD, cub1=^H,
        cud=\E[%p1%dB, cud1=\n, cuf=\E[%p1%dC, cuf1=\E[C,
        cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\E[A,
        cvvis=\E[?12;25h, dch=\E[%p1%dP, dch1=\E[P, dim=\E[2m,
        ......</code></pre>

<p>You might notice some of these sequences were the same codes from <code>script</code> earlier.
Also note that these sequences are specific to a certain terminal emulator type,
in this case <code>xterm</code>. There's a whole directory somewhere filled with repeated
descriptions for dozens of terminal types, most of which you will certainly never need.
In fact, many terminals have outdated terminfo descriptions or lie that
<code>TERM=xterm-256color</code>, which makes writing a library wrapper
<a href="https://github.com/neovim/neovim/blob/a0201b6ed37bae594bd0db2804c8ecff09a29e0e/src/nvim/tui/tui.c#L1585" >uniquely painful</a>.</p>

<p>Fortunately you've probably got a fun terminal library wrapper so you don't need
to worry right?</p>

<p>Well... not quite. Half the keys when modified, and especially mouse events will
simply not be reported by the terminal emulator due to <a href="https://invisible-island.net/xterm/modified-keys.html" >legacy encoding issues</a>.
On top of that displaying things is generally still your problem, and the only
graphical primitive available to you is sending text through what's essentially a pipe.
Because you're copying text in and out of the kernel, as well as waiting on slow
terminals to parse color control sequences, it's common to observe screen tearing
if your library <em>coughs and ncurses</em> fails to optimize output properly.
For those morbidly curious, this involves
insanity such as batch-drawing things with the same color to avoid outputting long
color-changing sequences and minimising movement of the terminal cursor - the only location
where text can be drawn on the screen.</p>

<p>But there's more!</p>

<p align="center"> <img src="../static/terminals.png"> </p>

<p>The concept of a character's display width is not well defined with terminals,
accustomed to a grid of monospace ascii characters, and so
no terminal emulator in existence can render wide and combining characters
<a href="https://github.com/Plisp/wcwidth-comparision" >consistently</a> though alacritty seems
to come close. This reflects another lack of standardization which means no TUI 
can draw emojis in a consistent way.</p>

<h2>deep breath and conclusion</h2>

<p>While the shell is handy for opaque textual command pipelines, programs needing
real user interaction should be implemented in something sane like SDL.</p>
 ]]></description> </item><item> <title>Editing abstraction not text (updated)</title> <link>https://plisp.github.io/posts/Editing-abstraction-not-text-updated.html</link> <pubDate>2021-11-29 10:24:59</pubDate> <author>plisp</author> <guid isPermaLink="true">https://plisp.github.io/posts/Editing-abstraction-not-text-updated.html</guid> <category><![CDATA[ editing ]]></category> <description><![CDATA[ <p>So I started off writing a <a href="https://github.com/Plisp/vico" >text editor</a> that would suit
my needs: being fully extensible via a scripting language <strong>and</strong> performant.  Along the
way I devised <a href="https://github.com/Plisp/libst" >an improvement</a> on the
<a href="https://en.wikipedia.org/wiki/Piece_table" >piece-table</a> which significantly outperforms
all existing similar data structures to my knowledge.  There was a small caveat to my
particular implementation - it exploited the fact that codepoint and line number tracking
are not crucial in the backend of a text editor (details in paper), meaning much of the
file did not need to be read with expensive system calls, instead lazily loaded by the
operating system's virtual memory subsystem.</p>

<p>Arguably at that point my implementation was not exactly comparable to others since I was
no longer providing the same abstract interface as typical text buffers. But the key
insight is that bytes, codepoints and lines are simply not the units in which we percieve
code.</p>

<p>When designing a development environment, I think a good premise is that not everything
is text, just as <a href="https://www.youtube.com/watch?v=9-IWMbJXoLM" >not everything is a file</a>.</p>

<!--more-->

<h3>Problems with text editing, bandaid solutions</h3>

<p>Treating code as a string of bytes leads to worse semantic awareness in tooling and
inevitable efficiency problems beyond text editing, even with things as simple as
<a href="https://code.visualstudio.com/blogs/2021/09/29/bracket-pair-colorization" >bracket
matching</a>,
which require knowledge of the source code's implicit structure, as some parens are part
of strings, comments escaped literals, etc.  Instead, a code editor's document
representation should reflect semantic structures like variables, blocks and function
definitions, while text remains a secondary format for serialization to disk.</p>

<p>Tools like tree-sitter and regex lexers which attempt to analyze code as text ultimately
fail when syntax depends on semantics. In the C example below, the correct highlighting
of the variable <code>a</code> needs to identify that <code>foo</code> is in fact a type and so the expression
casts <code>(a+3)</code> to a <code>foo</code> rather than calling the function <code>foo</code>.</p>

<p><code>c typedef int foo; (foo)(a + 3);</code></p>

<p>Of course, complete analysis of code essentially means rewriting a compiler frontend
which parses text and builds a graph of semantic objects, known as an Abstract Syntax
Graph or ASG.  This duplication of effort is unfortunately necessary to build good
tooling as compilers (libclang being an exception, however not incremental enough for use
in an editor) don't typically expose their internal representation of code. In an <a href="https://www.youtube.com/watch?v=39wlNRk-nAg" >ideal
world</a> compilers would produce artifacts
that syntax highlighting, code formatters, linters, completion and <code>ctags</code> can reuse.</p>

<p>And to address the elephant in the room - Microsoft's Language Server Protocol introduces
great friction (asynchronous procedure calls? UTF-16 indices?) for achieving relatively
mundane functionality and is inextensible.  There are two significant problems with
isolating the ASG in a separate process:</p>

<ul>
<li>Availability - Say you want to determine whether a variable is global in an unfamiliar
codebase.  This doesn't exist in the protocol and is not trivial to determine, so do you
hack it into the lsp server and client or wait for Microsoft to standardize a new call?</li>
<li>Granularity - Say you wanted to highlight all direct mutations of a variable in some
function.  This doesn't exist in the protocol, but could be implemented by calling
<code>DocumentHighlight</code>, which returns <em>all</em> references to the symbol in a file and whether
they are read/writes, and trimming the list to the current function body by using a
<code>DocumentSymbol</code> hierachy. However you've asked for <em>every</em> reference to the symbol,
which is significantly more work than necessary.</li>
</ul>

<h3>An incremental IDE</h3>

<p>If editor scripting could access the code's syntax tree, the above would be trivial.
However LSP's capabilities only scratch the surface of possibilities, representing the
lowest common denominator of a multitude of languages. Let's try a stream of
consciousness...  Given a database of types, function definitions, variables and an AST
it is possible to:</p>

<ul>
<li>provide scripting of highlighting modes, emphasizing particular variables, mutations
and accurate conventional semantic highlighting of keywords, types, etc.</li>
<li>incremental static analysis</li>
<li>augmenting hardcoded snippets, dynamically provide completion of valid control flow constructs</li>
<li>edit structurally, eliminating syntax errors</li>
<li>edit alternate visual 'projections' of a code model: C like python without extraneous braces and semicolons,
or even scratch (cursed), edit math equations typeset inline with latex, color pickers for rgb values...</li>
</ul>

<p align="center"> <img src="../static/cpython.png"> </p>

<ul>
<li>write code generating macros in the scripting language of the editor rather than the
programming language (more on this in future posts)</li>
<li>execute code in a REPL: live within the editor without waiting for a full recompilation</li>
<li>track memory allocations, detecting accesses out of bounds and identifying their source without leaving the editor and
running valgrind</li>
<li>debug by richly inspecting state and directly redefining functions</li>
<li>generate a control flow graph leading up to a debugger crash, displaying values of
variables involved at each branch (debug printing but automatic) or better:</li>
<li>reverse time by undoing observable side-effecting code (external routines like i/o are harder to
deal with, this might be possible if the OS was designed around persistence)</li>
</ul>

<p>Now some of these may be theoretically possible in a modern IDE, but with structural
editing operations that operate on the ASG while keeping it valid (possibly with
&quot;holes&quot;), reindexing is minimised and incrementality is possible, perhaps remedying the
sluggishness common to such tools.</p>

<h3>Reducing working memory load</h3>

<p>What's the point of all this?  It's important to note that computers once ran binary
machine code, before we moved to assembler, to familiar high-level languages like python,
java, rust to abstract away the low-level concerns peripheral to our mental model of a
program, closing in on the ideal: <code>working memory + screen = complete model of whatever
we're working on</code>.</p>

<p>While the abstractions of the programming language are crucial, being the raw materials
comprising a program, our tooling can accessibly display all the invariants intrinsic to
the code, allowing us to find and correct the structural issues undermining the
robustness of our constructions.  In this line of analogy, debugging with breakpoints is
akin to relying on photos taken blindfolded to determine the cause of a building's
collapse.  Keeping a full view of the relevant component within reach at all times
(especially following error) allows more precious working memory to be devoted to design;
easing implementation and debugging.</p>

<h3>It's hard</h3>

<p>But of course first you need to implement a compiler frontend, an executor, an editor and
make it all scalable. My first thought was a simple enough static language: C (languages
with true macro abstractions tend to be much
<a href="https://rust-analyzer.github.io/blog/2021/11/21/ides-and-macros.html" >harder</a> to analyse)
for which I now have a parser, but perhaps also a language could be designed that fully
eliminates the textual redundancy and works with the editing environment to incrementally
analyse program invariants.</p>

<p>More posts to come!</p>
 ]]></description> </item><item> <title>A trick for simpler priority queues</title> <link>https://plisp.github.io/posts/A-trick-for-simpler-priority-queues.html</link> <pubDate>2021-08-28 18:20:08</pubDate> <author>plisp</author> <guid isPermaLink="true">https://plisp.github.io/posts/A-trick-for-simpler-priority-queues.html</guid> <category><![CDATA[ data-structures ]]></category> <description><![CDATA[ <p>I almost forgot I had this blog setup, but today I found a interesting trick which almost nobody
seems to have used in their heaps so here it is
(<a href="https://github.com/vy/libpqueue/blob/master/src/pqueue.c" >update: someone did</a>).</p>

<!--more-->

<p><a href="http://opendatastructures.org/ods-python/10_Heaps.html" >Heaps</a> are a common structure
for implementing priority queues, being able to both extract the minimum/maximum priority
element and insert a new element in <code>O(log n)</code>. The typical implementation is an implicit
complete binary tree embedded within an array, which is simple and has good cache locality.</p>

<p>Normally the root of the heap is present at index 0, with the children of <code>i</code> at <code>2i+1</code>
and <code>2i+2</code>, and its parent at <code>(i-1)/2</code>. However by leaving index 0 empty and
indexing the heap from 1, you can simplify these calculations and save a few arithmetic ops.</p>

<p align="center">
  <img width="460" height="300" src="../static/heap.png">
</p>

<p>Additionally, if you <code>aligned_alloc</code> the heap array, you may be able to improve cache
alignment of children. For example, assuming 64-bit integer elements and cache lines, the 8
great-grandchildren of <code>a[i]</code> at indices <code>a[8i]</code> to <code>a[8i+7]</code> will lie in a single cache
line as 64 divides <code>8i * 8 bytes</code>. This allows prefetching multiple levels in advance.</p>

<p>Further if you keep the heap capacity as a power of 2, you get a complete binary tree,
and so the depth of a large heap should be obvious to the branch predictor. Then sifting
down only needs to check the validity of the right child since either both, or neither are
valid in a complete tree, which saves several comparisions when popping from the heap
(this can of course also be done in a 0-indexed heap by leaving the final element empty).</p>

<p>Combining these tricks yields quite a gain in simplicity and theoretically, performance
(benchmarks later?).</p>

<p>Here's some source code in C for a integer max heap, but the idea should be clear enough.
Details can be found in my <a href="https://github.com/plisp/dsdump" >collection of algorithms</a></p>

<pre><code><span class="code"><span class="symbol">typedef</span> <span class="symbol">struct</span> heap <span class="paren1">{<span class="code">
    size_t size, cap;
    <span class="symbol">long</span> *data;
</span>}</span> Heap;

Heap *heap_new<span class="paren1">(<span class="code"></span>)</span> <span class="paren1">{<span class="code">
    <span class="symbol">struct</span> heap *new = malloc<span class="paren2">(<span class="code"><span class="symbol">sizeof</span> *new</span>)</span>;
    new-&gt;size = 1;
    new-&gt;cap = 2;
    <span class="symbol">return</span> new;
</span>}</span>

<span class="comment">// sifts the element recently pushed to the index heap-&gt;size up as far as possible
</span><span class="symbol">int</span> sift_down<span class="paren1">(<span class="code">Heap *heap</span>)</span> <span class="paren1">{<span class="code">
    <span class="symbol">long</span> *a = heap-&gt;data;
    size_t i = heap-&gt;size, parent = i/2;
    <span class="comment">//
</span>    <span class="symbol">while</span> <span class="paren2">(<span class="code">parent &gt; 0 &amp;&amp; a<span class="paren3">[<span class="code">i</span>]</span> &gt; a<span class="paren3">[<span class="code">parent</span>]</span></span>)</span> <span class="paren2">{<span class="code">
        swap<span class="paren3">(<span class="code">&amp;a<span class="paren4">[<span class="code">i</span>]</span>, &amp;a<span class="paren4">[<span class="code">parent</span>]</span></span>)</span>;
        i = parent, parent = i/2;
    </span>}</span>
</span>}</span>

<span class="symbol">void</span> sift_down<span class="paren1">(<span class="code">Heap *heap</span>)</span> <span class="paren1">{<span class="code">
    <span class="symbol">long</span> *a = heap-&gt;data;
    <span class="symbol">for</span> <span class="paren2">(<span class="code">size_t i, max_child = 1, left, right;;</span>)</span> <span class="paren2">{<span class="code">
        i = max_child;
        left = i*2, right = i*2 + 1;
        <span class="symbol">if</span> <span class="paren3">(<span class="code">right &gt;= heap-&gt;size</span>)</span> break;
        <span class="comment">// swap with larger child &gt; other child
</span>        max_child = a<span class="paren3">[<span class="code">left</span>]</span> &gt; a<span class="paren3">[<span class="code">right</span>]</span> ? left : right;
        <span class="symbol">if</span> <span class="paren3">(<span class="code">a<span class="paren4">[<span class="code">max_child</span>]</span> &gt; a<span class="paren4">[<span class="code">i</span>]</span></span>)</span>
            swap<span class="paren3">(<span class="code">&amp;a<span class="paren4">[<span class="code">max_child</span>]</span>, &amp;a<span class="paren4">[<span class="code">i</span>]</span></span>)</span>;
        <span class="symbol">else</span> break;
    </span>}</span>
</span>}</span></span></code></pre>

<p>More posts to come soon.</p>
 ]]></description> </item><item> <title>2020-08-15</title> <link>https://plisp.github.io/posts/2020-08-15.html</link> <pubDate>2020-08-15 10:23:51</pubDate> <author>plisp</author> <guid isPermaLink="true">https://plisp.github.io/posts/2020-08-15.html</guid> <category><![CDATA[ meta ]]></category> <description><![CDATA[ <p>Switched from jekyll to coleslaw. Things look much nicer now.
Code highlighting is looking real sexy.</p>

<!--more-->

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> <span class="special">*my-fasldir*</span> <span class="string">"fasl/"</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> my-sly-compile-file <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">interactive</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let*</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">rootdir <span class="paren5">(<span class="code">projectile-project-root</span>)</span></span>)</span>
         <span class="paren4">(<span class="code">fasldir <span class="paren5">(<span class="code">concat <span class="paren6">(<span class="code">projectile-project-root</span>)</span> <span class="special">*my-fasldir*</span></span>)</span></span>)</span>
         <span class="paren4">(<span class="code">relative-dir <span class="paren5">(<span class="code">string-trim-right
                        <span class="paren6">(<span class="code">substring <span class="paren1">(<span class="code">buffer-file-name <span class="paren2">(<span class="code">current-buffer</span>)</span></span>)</span> <span class="paren1">(<span class="code">length rootdir</span>)</span></span>)</span>
                        <span class="string">"[^/]+"</span></span>)</span></span>)</span>
         <span class="paren4">(<span class="code">file-fasl-dir <span class="paren5">(<span class="code">concat fasldir relative-dir</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">make-directory file-fasl-dir t</span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">setq</span></i> sly-compile-file-options <span class="paren4">(<span class="code">list <span class="keyword">:fasl-directory</span> file-fasl-dir</span>)</span></span>)</span>
    <span class="paren3">(<span class="code">sly-compile-file</span>)</span></span>)</span></span>)</span>

<span class="comment">; if using use-package do
</span><span class="comment">; :bind (:map sly-editing-mode-map ("C-c C-k" . #'my-sly-compile-file))
</span><span class="comment">; otherwise
</span><span class="paren1">(<span class="code">bind-key <span class="string">"C-c C-k"</span> #'my-sly-compile-file sly-editing-mode-map</span>)</span></span></code></pre>

<p>The scope highlighting is not particularly useful at the moment as finding colors that don't clash with solarized is a real challenge.</p>
 ]]></description> </item> </channel> </rss>