<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"> <channel> <title>(gensym)</title> <link>https://plisp.github.io</link> <atom:link href="https://plisp.github.io/rss.xml" rel="self" type="application/rss+xml" /> <language>en-us</language> <pubDate>Sun, 16 Jan 2022 04:42:05 +0000</pubDate> <item> <title>Editing abstraction not text (updated)</title> <link>https://plisp.github.io/posts/Editing-abstraction-not-text-updated.html</link> <pubDate></pubDate> <author>plisp</author> <guid isPermaLink="true">https://plisp.github.io/posts/Editing-abstraction-not-text-updated.html</guid> <category><![CDATA[ editing date: 2021-11-29 10:24:59 ]]></category> <description><![CDATA[ <p>So I started off writing a <a href="https://github.com/Plisp/vico" >text editor</a> that would suit
my needs: being fully extensible via a scripting language <strong>and</strong> performant.  Along the
way I devised <a href="https://github.com/Plisp/libst" >an improvement</a> on the
<a href="https://en.wikipedia.org/wiki/Piece_table" >piece-table</a> which significantly outperforms
all existing similar data structures to my knowledge.  There was a small caveat to my
particular implementation - it exploited the fact that codepoint and line number tracking
are not crucial in the backend of a text editor (details in paper), meaning much of the
file did not need to be read with expensive system calls, instead lazily loaded by the
operating system's virtual memory subsystem.</p>

<p>Arguably at that point my implementation was not exactly comparable to others since I was
no longer providing the same abstract interface as typical text buffers. But the key
insight is that bytes, codepoints and lines are simply not the units in which we percieve
code.</p>

<p>When designing a development environment, I think a good premise is that not everything
is text, just as <a href="https://www.youtube.com/watch?v=9-IWMbJXoLM" >not everything is a file</a>.</p>

<!--more-->

<h3>Problems with text editing, bandaid solutions</h3>

<p>Treating code as a string of bytes leads to worse semantic awareness in tooling and
inevitable efficiency problems beyond text editing, even with things as simple as
<a href="https://code.visualstudio.com/blogs/2021/09/29/bracket-pair-colorization" >bracket
matching</a>,
which require knowledge of the source code's implicit structure, as some parens are part
of strings, comments escaped literals, etc.  Instead, a code editor's document
representation should reflect semantic structures like variables, blocks and function
definitions, while text remains a secondary format for serialization to disk.</p>

<p>Tools like tree-sitter and regex lexers which attempt to analyze code as text ultimately
fail when syntax depends on semantics. In the C example below, the correct highlighting
of the variable <code>a</code> needs to identify that <code>foo</code> is in fact a type and so the expression
casts <code>(a+3)</code> to a <code>foo</code> rather than calling the function <code>foo</code>.</p>

<p><code>c typedef int foo; (foo)(a + 3);</code></p>

<p>Of course, complete analysis of code essentially means rewriting a compiler frontend
which parses text and builds a graph of semantic objects, known as an Abstract Syntax
Graph or ASG.  This duplication of effort is unfortunately necessary to build good
tooling as compilers (libclang being an exception, however not incremental enough for use
in an editor) don't typically expose their internal representation of code. In an <a href="https://www.youtube.com/watch?v=39wlNRk-nAg" >ideal
world</a> compilers would produce artifacts
that syntax highlighting, code formatters, linters, completion and <code>ctags</code> can reuse.</p>

<p>And to address the elephant in the room - Microsoft's Language Server Protocol introduces
great friction (asynchronous procedure calls? UTF-16 indices?) for achieving relatively
mundane functionality and is inextensible.  There are two significant problems with
isolating the ASG in a separate process:</p>

<ul>
<li>Availability - Say you want to determine whether a variable is global in an unfamiliar
codebase.  This doesn't exist in the protocol and is not trivial to determine, so do you
hack it into the lsp server and client or wait for Microsoft to standardize a new call?</li>
<li>Granularity - Say you wanted to highlight all direct mutations of a variable in some
function.  This doesn't exist in the protocol, but could be implemented by calling
<code>DocumentHighlight</code>, which returns <em>all</em> references to the symbol in a file and whether
they are read/writes, and trimming the list to the current function body by using a
<code>DocumentSymbol</code> hierachy. However you've asked for <em>every</em> reference to the symbol,
which is significantly more work than necessary.</li>
</ul>

<h3>An incremental IDE</h3>

<p>If editor scripting could access the code's syntax tree, the above would be trivial.
However LSP's capabilities only scratch the surface of possibilities, representing the
lowest common denominator of a multitude of languages. Let's try a stream of
consciousness...  Given a database of types, function definitions, variables and an AST
it is possible to:</p>

<ul>
<li>provide scripting of highlighting modes, emphasizing particular variables, mutations
and accurate conventional semantic highlighting of keywords, types, etc.</li>
<li>incremental static analysis</li>
<li>augmenting hardcoded snippets, dynamically provide completion of valid control flow constructs</li>
<li>edit structurally, eliminating syntax errors</li>
<li>edit alternate visual 'projections' of a code model: C like python without extraneous braces and semicolons,
or even scratch (cursed), edit math equations typeset inline with latex, color pickers for rgb values...</li>
</ul>

<p align="center"> <img src="../static/cpython.png"> </p>

<ul>
<li>write code generating macros in the scripting language of the editor rather than the
programming language (more on this in future posts)</li>
<li>execute code in a REPL: live within the editor without waiting for a full recompilation</li>
<li>track memory allocations, detecting accesses out of bounds and identifying their source without leaving the editor and
running valgrind</li>
<li>debug by richly inspecting state and directly redefining functions</li>
<li>generate a control flow graph leading up to a debugger crash, displaying values of
variables involved at each branch (debug printing but automatic) or better:</li>
<li>reverse time by undoing observable side-effecting code (external routines like i/o are harder to
deal with, this might be possible if the OS was designed around persistence)</li>
</ul>

<p>Now some of these may be theoretically possible in a modern IDE, but with structural
editing operations that operate on the ASG while keeping it valid (possibly with
&quot;holes&quot;), reindexing is minimised and incrementality is possible, perhaps remedying the
sluggishness common to such tools.</p>

<h3>Reducing working memory load</h3>

<p>What's the point of all this?  It's important to note that computers once ran binary
machine code, before we moved to assembler, to familiar high-level languages like python,
java, rust to abstract away the low-level concerns peripheral to our mental model of a
program, closing in on the ideal: <code>working memory + screen = complete model of whatever
we're working on</code>.</p>

<p>While the abstractions of the programming language are crucial, being the raw materials
comprising a program, our tooling can accessibly display all the invariants intrinsic to
the code, allowing us to find and correct the structural issues undermining the
robustness of our constructions.  In this line of analogy, debugging with breakpoints is
akin to relying on photos taken blindfolded to determine the cause of a building's
collapse.  Keeping a full view of the relevant component within reach at all times
(especially following error) allows more precious working memory to be devoted to design;
easing implementation and debugging.</p>

<h3>It's hard</h3>

<p>But of course first you need to implement a compiler frontend, an executor, an editor and
make it all scalable. My first thought was a simple enough static language: C (languages
with true macro abstractions tend to be much
<a href="https://rust-analyzer.github.io/blog/2021/11/21/ides-and-macros.html" >harder</a> to analyse)
for which I now have a parser, but perhaps also a language could be designed that fully
eliminates the textual redundancy and works with the editing environment to incrementally
analyse program invariants.</p>

<p>More posts to come!</p>
 ]]></description> </item><item> <title>A trick for simpler priority queues</title> <link>https://plisp.github.io/posts/A-trick-for-simpler-priority-queues.html</link> <pubDate>2021-08-28 18:20:08</pubDate> <author>plisp</author> <guid isPermaLink="true">https://plisp.github.io/posts/A-trick-for-simpler-priority-queues.html</guid> <category><![CDATA[ data-structures ]]></category> <description><![CDATA[ <p>I almost forgot I had this blog setup, but today I found a interesting trick which almost nobody
seems to have used in their heaps so here it is
(<a href="https://github.com/vy/libpqueue/blob/master/src/pqueue.c" >update: someone did</a>).</p>

<!--more-->

<p><a href="http://opendatastructures.org/ods-python/10_Heaps.html" >Heaps</a> are a common structure
for implementing priority queues, being able to both extract the minimum/maximum priority
element and insert a new element in <code>O(log n)</code>. The typical implementation is an implicit
complete binary tree embedded within an array, which is simple and has good cache locality.</p>

<p>Normally the root of the heap is present at index 0, with the children of <code>i</code> at <code>2i+1</code>
and <code>2i+2</code>, and its parent at <code>(i-1)/2</code>. However by leaving index 0 empty and
indexing the heap from 1, you can simplify these calculations and save a few arithmetic ops.</p>

<p align="center">
  <img width="460" height="300" src="../static/heap.png">
</p>

<p>Additionally, if you <code>aligned_alloc</code> the heap array, you may be able to improve cache
alignment of children. For example, assuming 64-bit integer elements and cache lines, the 8
great-grandchildren of <code>a[i]</code> at indices <code>a[8i]</code> to <code>a[8i+7]</code> will lie in a single cache
line as 64 divides <code>8i * 8 bytes</code>. This allows prefetching multiple levels in advance.</p>

<p>Further if you keep the heap capacity as a power of 2, you get a complete binary tree,
and so the depth of a large heap should be obvious to the branch predictor. Then sifting
down only needs to check the validity of the right child since either both, or neither are
valid in a complete tree, which saves several comparisions when popping from the heap
(this can of course also be done in a 0-indexed heap by leaving the final element empty).</p>

<p>Combining these tricks yields quite a gain in simplicity and theoretically, performance
(benchmarks later?).</p>

<p>Here's some source code in C for a integer max heap, but the idea should be clear enough.
Details can be found in my <a href="https://github.com/plisp/dsdump" >collection of algorithms</a></p>

<pre><code><span class="code"><span class="symbol">typedef</span> <span class="symbol">struct</span> heap <span class="paren1">{<span class="code">
    size_t size, cap;
    <span class="symbol">long</span> *data;
</span>}</span> Heap;

Heap *heap_new<span class="paren1">(<span class="code"></span>)</span> <span class="paren1">{<span class="code">
    <span class="symbol">struct</span> heap *new = malloc<span class="paren2">(<span class="code"><span class="symbol">sizeof</span> *new</span>)</span>;
    new-&gt;size = 1;
    new-&gt;cap = 2;
    <span class="symbol">return</span> new;
</span>}</span>

<span class="comment">// sifts the element recently pushed to the index heap-&gt;size up as far as possible
</span><span class="symbol">int</span> sift_down<span class="paren1">(<span class="code">Heap *heap</span>)</span> <span class="paren1">{<span class="code">
    <span class="symbol">long</span> *a = heap-&gt;data;
    size_t i = heap-&gt;size, parent = i/2;
    <span class="comment">//
</span>    <span class="symbol">while</span> <span class="paren2">(<span class="code">parent &gt; 0 &amp;&amp; a<span class="paren3">[<span class="code">i</span>]</span> &gt; a<span class="paren3">[<span class="code">parent</span>]</span></span>)</span> <span class="paren2">{<span class="code">
        swap<span class="paren3">(<span class="code">&amp;a<span class="paren4">[<span class="code">i</span>]</span>, &amp;a<span class="paren4">[<span class="code">parent</span>]</span></span>)</span>;
        i = parent, parent = i/2;
    </span>}</span>
</span>}</span>

<span class="symbol">void</span> sift_down<span class="paren1">(<span class="code">Heap *heap</span>)</span> <span class="paren1">{<span class="code">
    <span class="symbol">long</span> *a = heap-&gt;data;
    <span class="symbol">for</span> <span class="paren2">(<span class="code">size_t i, max_child = 1, left, right;;</span>)</span> <span class="paren2">{<span class="code">
        i = max_child;
        left = i*2, right = i*2 + 1;
        <span class="symbol">if</span> <span class="paren3">(<span class="code">right &gt;= heap-&gt;size</span>)</span> break;
        <span class="comment">// swap with larger child &gt; other child
</span>        max_child = a<span class="paren3">[<span class="code">left</span>]</span> &gt; a<span class="paren3">[<span class="code">right</span>]</span> ? left : right;
        <span class="symbol">if</span> <span class="paren3">(<span class="code">a<span class="paren4">[<span class="code">max_child</span>]</span> &gt; a<span class="paren4">[<span class="code">i</span>]</span></span>)</span>
            swap<span class="paren3">(<span class="code">&amp;a<span class="paren4">[<span class="code">max_child</span>]</span>, &amp;a<span class="paren4">[<span class="code">i</span>]</span></span>)</span>;
        <span class="symbol">else</span> break;
    </span>}</span>
</span>}</span></span></code></pre>

<p>More posts to come soon.</p>
 ]]></description> </item><item> <title>2020-08-15</title> <link>https://plisp.github.io/posts/2020-08-15.html</link> <pubDate>2020-08-15 10:23:51</pubDate> <author>plisp</author> <guid isPermaLink="true">https://plisp.github.io/posts/2020-08-15.html</guid> <category><![CDATA[ meta ]]></category> <description><![CDATA[ <p>Switched from jekyll to coleslaw. Things look much nicer now.
Code highlighting is looking real sexy.</p>

<!--more-->

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defvar</span></i> <span class="special">*my-fasldir*</span> <span class="string">"fasl/"</span></span>)</span>

<span class="paren1">(<span class="code"><i><span class="symbol">defun</span></i> my-sly-compile-file <span class="paren2">(<span class="code"></span>)</span>
  <span class="paren2">(<span class="code">interactive</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">let*</span></i> <span class="paren3">(<span class="code"><span class="paren4">(<span class="code">rootdir <span class="paren5">(<span class="code">projectile-project-root</span>)</span></span>)</span>
         <span class="paren4">(<span class="code">fasldir <span class="paren5">(<span class="code">concat <span class="paren6">(<span class="code">projectile-project-root</span>)</span> <span class="special">*my-fasldir*</span></span>)</span></span>)</span>
         <span class="paren4">(<span class="code">relative-dir <span class="paren5">(<span class="code">string-trim-right
                        <span class="paren6">(<span class="code">substring <span class="paren1">(<span class="code">buffer-file-name <span class="paren2">(<span class="code">current-buffer</span>)</span></span>)</span> <span class="paren1">(<span class="code">length rootdir</span>)</span></span>)</span>
                        <span class="string">"[^/]+"</span></span>)</span></span>)</span>
         <span class="paren4">(<span class="code">file-fasl-dir <span class="paren5">(<span class="code">concat fasldir relative-dir</span>)</span></span>)</span></span>)</span>
    <span class="paren3">(<span class="code">make-directory file-fasl-dir t</span>)</span>
    <span class="paren3">(<span class="code"><i><span class="symbol">setq</span></i> sly-compile-file-options <span class="paren4">(<span class="code">list <span class="keyword">:fasl-directory</span> file-fasl-dir</span>)</span></span>)</span>
    <span class="paren3">(<span class="code">sly-compile-file</span>)</span></span>)</span></span>)</span>

<span class="comment">; if using use-package do
</span><span class="comment">; :bind (:map sly-editing-mode-map ("C-c C-k" . #'my-sly-compile-file))
</span><span class="comment">; otherwise
</span><span class="paren1">(<span class="code">bind-key <span class="string">"C-c C-k"</span> #'my-sly-compile-file sly-editing-mode-map</span>)</span></span></code></pre>

<p>The scope highlighting is not particularly useful at the moment as finding colors that don't clash with solarized is a real challenge.</p>
 ]]></description> </item> </channel> </rss>