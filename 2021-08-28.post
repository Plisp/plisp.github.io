;;;;;
title: A trick for simpler priority queues
tags: data-structures
date: 2021-08-28 18:20:08
format: md
;;;;;

I almost forgot I had this blog setup, but today I found a interesting trick which almost nobody
seems to have used in their heaps so here it is
([update: someone did](https://github.com/vy/libpqueue/blob/master/src/pqueue.c)).

<!--more-->

[Heaps](http://opendatastructures.org/ods-python/10_Heaps.html) are a common structure
for implementing priority queues, being able to both extract the minimum/maximum priority
element and insert a new element in `O(log n)`. The typical implementation is an implicit
complete binary tree embedded within an array, which is simple and has good cache locality.

Normally the root of the heap is present at index 0, with the children of `i` at `2i+1`
and `2i+2`, and its parent at `(i-1)/2`. However by leaving index 0 empty and
indexing the heap from 1, you can simplify these calculations and save a few arithmetic ops.

<p align="center">
  <img width="460" height="300" src="../static/heap.png">
</p>

Additionally, if you `aligned_alloc` the heap array, you may be able to improve cache
alignment of children. For example, assuming 64-bit integer elements and cache lines, the 8
great-grandchildren of `a[i]` at indices `a[8i]` to `a[8i+7]` will lie in a single cache
line as 64 divides `8i * 8 bytes`. This allows prefetching multiple levels in advance.

Further if you keep the heap capacity as a power of 2, you get a complete binary tree,
and so the depth of a large heap should be obvious to the branch predictor. Then sifting
down only needs to check the validity of the right child since either both, or neither are
valid in a complete tree, which saves several comparisions when popping from the heap
(this can of course also be done in a 0-indexed heap by leaving the final element empty).

Combining these tricks yields quite a gain in simplicity and theoretically, performance
(benchmarks later?).

Here's some source code in C for a integer max heap, but the idea should be clear enough.
Details can be found in my [collection of algorithms](https://github.com/plisp/dsdump)

```c
typedef struct heap {
	size_t size, cap;
	long *data;
} Heap;

Heap *heap_new() {
	struct heap *new = malloc(sizeof *new);
	new->size = 1;
	new->cap = 2;
	return new;
}

// sifts the element recently pushed to the index heap->size up as far as possible
int sift_up(Heap *heap) {
  	long *a = heap->data;
	size_t i = heap->size, parent = i/2;
	//
	while (parent > 0 && a[i] > a[parent]) {
		swap(&a[i], &a[parent]);
		i = parent, parent = i/2;
	}
}

void sift_down(Heap *heap) {
	long *a = heap->data;
	for (size_t i, max_child = 1, left, right;;) {
		i = max_child;
		left = i*2, right = i*2 + 1;
		if (right >= heap->size) break;
		// swap with larger child > other child
		max_child = a[left] > a[right] ? left : right;
		if (a[max_child] > a[i])
			swap(&a[max_child], &a[i]);
		else break;
	}
}
```

More posts to come soon.
